學習歷程
====
    我一直想先釐清，BTS運作上的本質是甚麼?
    為甚麼這麼說?
    在我準備動手開始打程式碼的時候
    我驚奇的發現，我有個疑惑，我為甚麼要建一棵樹出來?
    本來[63,35,36,84,59,64]，只要任何陣列皆可自成一棵樹呀!只差千奇百怪而已
    它不像之前的sort，因為要比大小，所以陣列的數字順序要移動，整個數列會要更動，BTS從頭到腳走完，就建出一顆固定不變的樹，不需要更動
    除了需要變動當中的數值時，我才需要改動它，那我平時，我建它幹甚麼?因為我接下來不會移動，我好好用list形式儲存就好啦!!
    我後來想到的答案是
    BST的好處，正常情況下由於它的架構導致，查找非常快，而這架構有它組建的規則。當我們要做查詢、修改時，這時才想起要建樹，這時等於要從頭到尾都跑過一遍
    那建樹的實益發揮不出來，所以建樹不是為了馬上用，主要先將其儲存，等到查詢修改再拿出來就很快，感覺很像資料庫，資料依一定格式輸入進去，等要查找，
    按圖索驥就很快了，我個人覺得因為BTS，本質也是一棵樹，所以在不具備各種功能前，就當成一種儲存的特定架構
    建好就放在那一種儲存當有需要時，再用這個東西去做修改、查詢
    那要怎麼建呢?
    首先要認識它的規則，比父節點大的放一邊，比父節點小的放另一邊
    BTS的建法，跟順序具有很大的關係，index[1]，先丟進去去比，一開始沒有東西，沒有比它大，沒有比它小，甚至它是甚麼也不知道，所以它就不用移動
    第一個就成為父節點，檢視下一個，但它又分一左一右，所以跟父節點比有幾個特性
    1.它會跟好幾個父節點去比
    2.最後一個父節點不知是誰?
    第二點，我原本想說，我可以用這個方向切入，找到最後父節點意味著它的上方就是它，就可以用這個來建起一棵樹，除了第一個點以外，都有一個父節點
    那我就可避開第一點，因為第一點你要跟數量不明、數字也不明的父節點去比，第二點試你知道數量，但數字不明的情況，相較第一點，第二點是更加好的情況
    ，因為比較簡單，易於分析，對於解題輪廓更加清晰，如果能破解其規律和讓數字明朗那就更好
    按此思路，我曾嘗試去找，過程複雜
    為避免跟上次一樣，很長，我簡短幾句講完
    1.需不需要全部都找?
    我發現只要找會進去之前的數字即可
    EX.[63,25,88,94,35]
    輪到94要丟進去去建一棵樹，我不用將所有數列都比較過
    我只要跟63,25,88三個數字去比，就可以了
    但還能不能再把範圍縮小
    2.跟前面的數字比 ok
    3.跟前面最相近的數字比 我以為可以，反思的結果是不行
    我為甚麼會用最相近的數字呢?
    因為在比大小的過程中，我想說會一個接一個去跟父節點比，那跟某個父節點相近的數字在比大小的過程，某個父節點比誰大，比誰小
    跟父節點相近的數字亦會如此嘛! 會逐漸往父節點方向去移動，因為父節點也是按此流程移動到現在的位置上的
    所以第一個要確認是在前面，第二個條件是最相近，我預想會接在父節點下方，例如上述94，最接近的是88，但這在某種情況有問題，[34,68,66,69,68]
    當我要填第二個68時，最相近的數字是68，它的左右兩邊已占滿，除了這種情塊外，還有一種情況是67,69,68或69,67,68 對68而言這兩種結果不一樣，
    67、69對68等距，根本無法選擇，因為我的構想要求是跟前面最相近的數字，到底要接67、還69就無法選擇了
    所以我乖乖的就照一個一個去比
    我發現一件事
    
    
    
    
