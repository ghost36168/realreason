參考資料
====
https://blog.csdn.net/u011437229/article/details/53188837
https://www.javatpoint.com/breadth-first-search-algorithm
https://www.itread01.com/content/1543634648.html
流程圖
------
    先有個起始點

    就將這個放在QUEUE01

    QUEUE02 放 None

    這起始點有多個跟他緊鄰一個距離的點

    接下來

    將起始點改放在QUEUE02

    將多個跟他緊鄰一個距離的點放進QUEUE01

    如何進行，動態推進?

    按字母順序去取

    可能可以依此原則

    將下一個跟緊鄰的點放進QUEUE02

    起始點這緊鄰的附近點放進 QUEUE01

    還有個原則，那附近的點可能會重複

    所以要另想辦法

    因此多出一個原則--重複的要思考
    
    這有幾種選擇
    第一種:在放進queue前就將他跳過
    第二種:放進queue01中，跟queue02比較，看有沒有重複，重複的刪除
    
    (這兩種，我後來想想。因為助教一定是給list的格式，這格式感覺蠻好刪除的，且第一種恐怕會有複雜的設計
    乾脆用第二種，找出重複的刪除)

    遞迴這動作
    
    總結:
    我要完成三個區塊
    第一、將一個queue移動另一個queue
    第二、處理重複的部分:
        1.如何辨別重複的部分(我才能做下方的刪除動作)
        2.刪除重複的部分
    第三、遞迴這動作
    例子，在下方
圖片
------
![image](https://github.com/ghost36168/realreason/blob/master/%E5%9C%96%E7%89%87/hW5.jpg)

學習歷程
------
        所以我觀察這張圖和我列的順序，思考我該怎麼實現，所以我先用list做實驗，分析過程中會遇到甚麼問題，
        因為直接用物件導向，臨時看不出有沒有出錯，邏輯可能通，但可能不會是我想要的結果。那我目前模擬的結果，
        是走到將東西從queue01放到queue02中這是可行的，第一步應該是可行的，我卡在第二步的1.
圖片
-------
![image](https://github.com/ghost36168/realreason/blob/master/%E5%9C%96%E7%89%87/HW5%E6%A8%A1%E6%93%AC.PNG)

BFS原理
------
    精神:先找最靠近自己的
DSF原理
------
    精神:一直往深處走，直到找到解或者走不下去為止
兩者比較
------
    兩者不同處:基本精神就不同了
    兩者相同處:基本演算是相同的

